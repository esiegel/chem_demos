subprojects {

   repositories {
       mavenCentral()

       flatDir {
         dirs '../libs'
       }
   }

   // java plugin.
   apply plugin: "java"
   apply plugin: "eclipse"

   // custom source layout
   sourceSets {
       main {
           java {
               srcDir 'src'
           }
       }
   }

   // depend on jogl
   dependencies {
      implementation  name: 'gluegen'
      implementation  name: 'gluegen-rt'
      implementation  name: 'jogl-all'
      implementation  group: 'org.swinglabs', name: 'swing-layout', version: '1.0.3'

      // Download the native libraries for you platform.  Currently OSX.
      implementation  name: 'gluegen-rt-natives-macosx-universal'
      implementation  name: 'jogl-all-natives-macosx-universal'
   }

   // Task to copy all of the jars.
   //
   // We need to copy the libraries to a single directory.  The jogl and gluegen
   // jars attempt to load native JNI libraries, those which are embedded within
   // the "natives" jars, by searching the same directory.  Sadly Gradle downloads
   // its dependencies into different directories.
   task copyLibs {
     doLast {
        copy {
           from sourceSets.main.runtimeClasspath
           into 'build/libs'
           include '**/*.jar'
        }
     }
   }

   // Copy libaries before creating the jar.
   jar.dependsOn(copyLibs)

   // Finds all jars in the libs directory and produces the manifests classpath
   ext.generateManifestClasspath = { ->
      def libsDir  = jar.destinationDir
      def paths = libsDir.listFiles()*.getAbsolutePath()

      // our classpath should only include the dependencies, not itself.
      paths.removeAll { it.endsWith(jar.archiveName) }

      return paths.join(' ')
   }

   // Running the code via the jars, since it has the correct jni libs paths.
   // Equivalent to running "java -jar PATH_TO_JAR".
   task run(dependsOn:jar) {
     doLast {
        ant.java(jar: jar.archivePath, fork:true)
     }
   }
}
